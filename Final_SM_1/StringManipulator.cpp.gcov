        -:    0:Source:StringManipulator.cpp
        -:    0:Graph:StringManipulator.gcno
        -:    0:Data:StringManipulator.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include "StringManipulator.h"
        -:    2:#include <algorithm>
        -:    3:#include <cctype>
        -:    4:#include <sstream>
        -:    5:#include <iterator>
        -:    6:#include <map>
        -:    7:#include <stdexcept>
        -:    8:#include <locale>
        -:    9:#include <regex>
        -:   10:#include <numeric>
        -:   11:
        2:   12:std::string StringManipulator::reverse(const std::string& str) {
        2:   13:    std::string reversed = str;
        2:   14:    std::reverse(reversed.begin(), reversed.end());
        2:   15:    return reversed;
        4:   16:}
        -:   17:
        1:   18:std::string StringManipulator::toUpperCase(const std::string& str) {
        1:   19:    std::string upper = str;
        2:   20:    std::transform(upper.begin(), upper.end(), upper.begin(),
       26:   21:                   [](unsigned char c) -> unsigned char { return std::toupper(c); });
        1:   22:    return upper;
        2:   23:}
        -:   24:
        1:   25:std::string StringManipulator::toLowerCase(const std::string& str) {
        1:   26:    std::string lower = str;
        2:   27:    std::transform(lower.begin(), lower.end(), lower.begin(),
       26:   28:                   [](unsigned char c) -> unsigned char { return std::tolower(c); });
        1:   29:    return lower;
        2:   30:}
        -:   31:
        1:   32:std::string StringManipulator::replace(const std::string& str, const std::string& from, const std::string& to) {
        1:   33:    std::string result = str;
        1:   34:    size_t start_pos = 0;
        4:   35:    while ((start_pos = result.find(from, start_pos)) != std::string::npos) {
        1:   36:        result.replace(start_pos, from.length(), to);
        1:   37:        start_pos += to.length();
        -:   38:    }
        1:   39:    return result;
        2:   40:}
        -:   41:
        1:   42:std::string StringManipulator::remove(const std::string& str, const std::string& substring) {
        1:   43:    std::string result = str;
        1:   44:    size_t start_pos = 0;
        4:   45:    while ((start_pos = result.find(substring, start_pos)) != std::string::npos) {
        1:   46:        result.erase(start_pos, substring.length());
        -:   47:    }
        1:   48:    return result;
        2:   49:}
        -:   50:
        1:   51:int StringManipulator::countWords(const std::string& str) {
        1:   52:    std::istringstream stream(str);
        4:   53:    return std::distance(std::istream_iterator<std::string>(stream), std::istream_iterator<std::string>());
        1:   54:}
        -:   55:
        1:   56:bool StringManipulator::isPalindrome(const std::string& str) {
        1:   57:    std::string cleaned;
        3:   58:    std::remove_copy_if(str.begin(), str.end(), std::back_inserter(cleaned),
       10:   59:                        [](char c) -> bool { return !std::isalnum(c); });
        1:   60:    std::string reversed = cleaned;
        1:   61:    std::reverse(reversed.begin(), reversed.end());
        1:   62:    return std::equal(cleaned.begin(), cleaned.end(), reversed.begin(),
       10:   63:                      [](char a, char b) -> bool { return std::tolower(a) == std::tolower(b); });
        1:   64:}
        -:   65:
        1:   66:size_t StringManipulator::findSubstring(const std::string& str, const std::string& substring) {
        1:   67:    size_t position = str.find(substring);
        1:   68:    if (position == std::string::npos) {
    #####:   69:        throw std::runtime_error("Substring not found in the string.");
        -:   70:    }
        1:   71:    return position;
    #####:   72:}
        -:   73:
        1:   74:std::vector<std::string> StringManipulator::split(const std::string& str, char delimiter) {
        1:   75:    std::vector<std::string> tokens;
        1:   76:    std::istringstream tokenStream(str);
        1:   77:    std::string token;
       12:   78:    while (std::getline(tokenStream, token, delimiter)) {
        2:   79:        if (!token.empty()) {
        2:   80:            tokens.push_back(token);
        2:   81:        }
        -:   82:    }
        1:   83:    return tokens;
        2:   84:}
        -:   85:
    #####:   86:std::string StringManipulator::rot13(const std::string& str) {
    #####:   87:    std::string encoded = str;
    #####:   88:    for (char& c : encoded) {
    #####:   89:        if (isalpha(c)) {
    #####:   90:            char base = islower(c) ? 'a' : 'A';
    #####:   91:            c = (c - base + 13) % 26 + base;
    #####:   92:        }
        -:   93:    }
    #####:   94:    return encoded;
    #####:   95:}
        -:   96:
    #####:   97:std::map<char, int> StringManipulator::charFrequency(const std::string& str) {
    #####:   98:    std::map<char, int> freq;
    #####:   99:    for (char c : str) {
    #####:  100:        if (isalpha(c)) {
    #####:  101:            c = tolower(c);
    #####:  102:            freq[c]++;
    #####:  103:        }
        -:  104:    }
    #####:  105:    return freq;
    #####:  106:}
        -:  107:
    #####:  108:std::string StringManipulator::trim(const std::string& str) {
    #####:  109:    auto front = std::find_if_not(str.begin(), str.end(), [](unsigned char ch) { return std::isspace(ch); });
    #####:  110:    auto back = std::find_if_not(str.rbegin(), str.rend(), [](unsigned char ch) { return std::isspace(ch); }).base();
    #####:  111:    if (back <= front) {
    #####:  112:        return "";
        -:  113:    }
    #####:  114:    return std::string(front, back);
    #####:  115:}
        -:  116:
    #####:  117:bool StringManipulator::startsWith(const std::string& str, const std::string& substring) {
    #####:  118:    return str.substr(0, substring.size()) == substring;
        -:  119:}
        -:  120:
    #####:  121:bool StringManipulator::endsWith(const std::string& str, const std::string& substring) {
    #####:  122:    if (str.length() >= substring.length()) {
    #####:  123:        return str.compare(str.length() - substring.length(), substring.length(), substring) == 0;
        -:  124:    }
    #####:  125:    return false;
    #####:  126:}
        -:  127:
        1:  128:std::string StringManipulator::digitsToWords(const std::string& str) {
        -:  129:    static const char* words[] = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"};
        1:  130:    std::string result;
       14:  131:    for (char c : str) {
        3:  132:        if (isdigit(c)) {
        7:  133:            if (!result.empty()) result += " ";
        3:  134:            result += words[c - '0'];
        3:  135:        }
        -:  136:    }
        1:  137:    return result;
        2:  138:}
        -:  139:
        1:  140:std::string StringManipulator::interleave(const std::string& str1, const std::string& str2) {
        1:  141:    std::string result;
        1:  142:    auto it1 = str1.begin(), it2 = str2.begin();
       13:  143:    while (it1 != str1.end() || it2 != str2.end()) {
        9:  144:        if (it1 != str1.end()) result += *it1++;
        9:  145:        if (it2 != str2.end()) result += *it2++;
        -:  146:    }
        1:  147:    return result;
        2:  148:}
        -:  149:
        1:  150:std::vector<size_t> StringManipulator::findAllSubstrings(const std::string& str, const std::string& substring) {
        1:  151:    std::vector<size_t> positions;
        1:  152:    size_t pos = str.find(substring, 0);
        8:  153:    while (pos != std::string::npos) {
        3:  154:        positions.push_back(pos);
        3:  155:        pos = str.find(substring, pos + substring.length());
        -:  156:    }
        1:  157:    return positions;
        2:  158:}
        -:  159:
    #####:  160:std::string StringManipulator::invertCase(const std::string& str) {
    #####:  161:    std::string result = str;
    #####:  162:    std::transform(result.begin(), result.end(), result.begin(), [](unsigned char c) -> unsigned char {
    #####:  163:        if (isupper(c)) {
    #####:  164:            return static_cast<unsigned char>(tolower(c));  // Cast to ensure type consistency
        -:  165:        }
    #####:  166:        if (islower(c)) {
    #####:  167:            return static_cast<unsigned char>(toupper(c));  // Cast to ensure type consistency
        -:  168:        }
    #####:  169:        return c;  // No cast needed here because 'c' is already unsigned char
    #####:  170:    });
    #####:  171:    return result;
    #####:  172:}
        -:  173:
        -:  174:
        1:  175:std::string StringManipulator::shuffle(const std::string& str) {
        1:  176:    std::string shuffled = str;
        1:  177:    std::random_shuffle(shuffled.begin(), shuffled.end());
        1:  178:    return shuffled;
        2:  179:}
        -:  180:
    #####:  181:std::string StringManipulator::join(const std::vector<std::string>& strings, const std::string& delimiter) {
    #####:  182:    return std::accumulate(strings.begin(), strings.end(), std::string(),
    #####:  183:                           [&delimiter](const std::string& a, const std::string& b) -> std::string {
    #####:  184:                               return a.empty() ? b : a + delimiter + b;
    #####:  185:                           });
    #####:  186:}
        -:  187:
    #####:  188:std::string StringManipulator::normalizeSpaces(const std::string& str) {
    #####:  189:    std::string normalized;
    #####:  190:    std::unique_copy(str.begin(), str.end(), std::back_inserter(normalized), 
    #####:  191:                     [](char a, char b) { return std::isspace(a) && std::isspace(b) && a == b; });
    #####:  192:    return normalized;
    #####:  193:}
        -:  194:
    #####:  195:std::string StringManipulator::capitalizeWords(const std::string& str) {
    #####:  196:    std::string capitalized;
    #####:  197:    bool newWord = true;
    #####:  198:    for (char ch : str) {
    #####:  199:        if (std::isspace(ch)) {
    #####:  200:            newWord = true;
    #####:  201:        } else if (newWord) {
    #####:  202:            ch = std::toupper(ch);
    #####:  203:            newWord = false;
    #####:  204:        }
    #####:  205:        capitalized += ch;
        -:  206:    }
    #####:  207:    return capitalized;
    #####:  208:}
        -:  209:
    #####:  210:std::string StringManipulator::reverseWords(const std::string& str) {
    #####:  211:    std::istringstream iss(str);
    #####:  212:    std::vector<std::string> words(std::istream_iterator<std::string>{iss}, std::istream_iterator<std::string>());
    #####:  213:    std::reverse(words.begin(), words.end());
    #####:  214:    return join(words, " ");
    #####:  215:}
        -:  216:
    #####:  217:std::string StringManipulator::encodeHTML(const std::string& str) {
    #####:  218:    std::string encoded;
    #####:  219:    for (char ch : str) {
    #####:  220:        switch (ch) {
    #####:  221:            case '&': encoded.append("&amp;"); break;
    #####:  222:            case '<': encoded.append("&lt;"); break;
    #####:  223:            case '>': encoded.append("&gt;"); break;
    #####:  224:            case '"': encoded.append("&quot;"); break;
    #####:  225:            case '\'': encoded.append("&#39;"); break;
    #####:  226:            default: encoded.push_back(ch); break;
        -:  227:        }
        -:  228:    }
    #####:  229:    return encoded;
    #####:  230:}
